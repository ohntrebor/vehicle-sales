# ===========================================
# DEPLOYMENT - PostgreSQL Database (para Vehicle Catalog)
# ===========================================
# Define como o PostgreSQL será executado no cluster
# Baseado na configuração do docker-compose

apiVersion: apps/v1
kind: Deployment
metadata:
  # Nome do Deployment
  name: postgres
  
  # Namespace onde será criado
  namespace: vehicle-sales
  
  # Labels para organização e seleção
  labels:
    app: postgres
    component: database
    tier: data
    version: "16"
    service: vehicle-catalog

spec:
  # ===========================================
  # Configuração de Réplicas
  # ===========================================
  # PostgreSQL básico suporta apenas 1 réplica
  # Para HA, use PostgreSQL com replicação ou operadores
  replicas: 1
  
  # ===========================================
  # Estratégia de Update
  # ===========================================
  strategy:
    # Recreate = derruba o pod antigo antes de criar o novo
    # RollingUpdate = cria novo pod antes de derrubar o antigo
    type: Recreate  # Banco de dados deve usar Recreate
  
  # ===========================================
  # Seletor de Pods
  # ===========================================
  # Define quais pods este Deployment gerencia
  selector:
    matchLabels:
      app: postgres
      component: database
  
  # ===========================================
  # Template do Pod
  # ===========================================
  template:
    metadata:
      # Labels do Pod (devem corresponder ao selector)
      labels:
        app: postgres
        component: database
        tier: data
        service: vehicle-catalog
    
    spec:
      # ===========================================
      # Containers
      # ===========================================
      containers:
        - name: postgres
          
          # Imagem do PostgreSQL
          # 16-alpine = versão 16 com Alpine Linux (menor)
          # 16 = versão 16 com Debian (maior, mais ferramentas)
          # latest = última versão (não use em produção!)
          image: postgres:16-alpine
          
          # Política de pull da imagem
          # Always = sempre baixa a imagem
          # IfNotPresent = baixa apenas se não existir
          # Never = nunca baixa, usa local
          imagePullPolicy: IfNotPresent
          
          # ===========================================
          # Portas
          # ===========================================
          ports:
            - containerPort: 5432      # Porta padrão do PostgreSQL
              name: postgres           # Nome da porta para referência
              protocol: TCP            # Protocolo TCP
          
          # ===========================================
          # Variáveis de Ambiente
          # ===========================================
          env:
            # Usuário do banco de dados
            - name: POSTGRES_USER
              valueFrom:
                secretKeyRef:
                  name: vehicle-sales-secrets
                  key: postgres-username
            
            # Senha do usuário
            - name: POSTGRES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: vehicle-sales-secrets
                  key: postgres-password
            
            # Nome do banco de dados inicial
            - name: POSTGRES_DB
              valueFrom:
                secretKeyRef:
                  name: vehicle-sales-secrets
                  key: postgres-database
            
            # Diretório dos dados (conforme docker-compose)
            - name: PGDATA
              value: "/var/lib/postgresql/data/pgdata"
            
            # Configurações de performance (opcional)
            # - name: POSTGRES_INITDB_ARGS
            #   value: "--auth-host=md5"
            
            # Configurações adicionais (opcional)
            # - name: POSTGRES_HOST_AUTH_METHOD
            #   value: "md5"  # Método de autenticação
          
          # ===========================================
          # Volumes
          # ===========================================
          volumeMounts:
            # Volume para dados persistentes
            - name: postgres-storage
              mountPath: /var/lib/postgresql/data
            
            # Volume para scripts de inicialização (opcional)
            # - name: init-scripts
            #   mountPath: /docker-entrypoint-initdb.d
            #   readOnly: true
          
          # ===========================================
          # Recursos
          # ===========================================
          resources:
            # Recursos mínimos garantidos
            requests:
              memory: "256Mi"   # 256MB RAM mínimo
              cpu: "250m"       # 0.25 CPU cores
            
            # Recursos máximos permitidos
            limits:
              memory: "1Gi"     # 1GB RAM máximo
              cpu: "500m"       # 0.5 CPU cores
          
          # ===========================================
          # Health Checks
          # ===========================================
          
          # Liveness Probe - verifica se o container está vivo
          # Se falhar, Kubernetes reinicia o container
          livenessProbe:
            exec:
              command:
                - sh
                - -c
                - "pg_isready -U $POSTGRES_USER -d $POSTGRES_DB"
            initialDelaySeconds: 30    # Aguarda 30s após iniciar
            periodSeconds: 10          # Verifica a cada 10s
            timeoutSeconds: 5          # Timeout de 5s
            failureThreshold: 3        # Falha após 3 tentativas
            successThreshold: 1        # Sucesso após 1 tentativa OK
          
          # Readiness Probe - verifica se está pronto para receber tráfego
          # Se falhar, remove o pod do load balancer
          readinessProbe:
            exec:
              command:
                - sh
                - -c
                - "pg_isready -U $POSTGRES_USER -d $POSTGRES_DB"
            initialDelaySeconds: 5     # Aguarda 5s após iniciar
            periodSeconds: 5           # Verifica a cada 5s
            timeoutSeconds: 3          # Timeout de 3s
            failureThreshold: 3        # Falha após 3 tentativas
            successThreshold: 1        # Sucesso após 1 tentativa OK
          
          # Startup Probe - verifica inicialização lenta (opcional)
          # startupProbe:
          #   exec:
          #     command:
          #       - sh
          #       - -c
          #       - "pg_isready -U $POSTGRES_USER -d $POSTGRES_DB"
          #   initialDelaySeconds: 0
          #   periodSeconds: 10
          #   timeoutSeconds: 5
          #   failureThreshold: 30    # Permite até 5 minutos para iniciar
      
      # ===========================================
      # Volumes
      # ===========================================
      volumes:
        # Volume persistente para dados
        - name: postgres-storage
          persistentVolumeClaim:
            claimName: postgres-pvc
        
        # Volume para scripts de inicialização (opcional)
        # - name: init-scripts
        #   configMap:
        #     name: postgres-init-scripts

---

# ===========================================
# PVC - Persistent Volume Claim para PostgreSQL
# ===========================================
# Solicita armazenamento persistente para o banco de dados

apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  # Nome do PVC que será referenciado pelo Deployment do PostgreSQL
  name: postgres-pvc
  
  # Namespace onde o PVC será criado
  namespace: vehicle-sales
  
  # Labels para organização
  labels:
    app: postgres
    component: database-storage
    tier: persistence
    service: vehicle-catalog

spec:
  # ===========================================
  # Modo de Acesso
  # ===========================================
  # ReadWriteOnce (RWO) = volume pode ser montado read-write por um único node
  # ReadOnlyMany (ROX) = volume pode ser montado read-only por vários nodes
  # ReadWriteMany (RWX) = volume pode ser montado read-write por vários nodes
  accessModes:
    - ReadWriteOnce  # PostgreSQL precisa de acesso exclusivo
  
  # ===========================================
  # Recursos Solicitados
  # ===========================================
  resources:
    requests:
      # Tamanho do volume
      # Desenvolvimento: 2Gi é suficiente
      # Produção: ajuste conforme necessidade (10Gi, 50Gi, 100Gi+)
      storage: 2Gi
  
  # ===========================================
  # Storage Class
  # ===========================================
  # Define o tipo de armazenamento
  # standard = disco padrão do cluster
  # fast/ssd = disco SSD (se disponível)
  # slow/hdd = disco HDD econômico
  # Minikube: use 'standard'
  # AWS EKS: use 'gp2' ou 'gp3'
  # GKE: use 'standard' ou 'pd-ssd'
  # Azure AKS: use 'default' ou 'managed-premium'
  storageClassName: standard
  
  # ===========================================
  # Volume Mode 
  # ===========================================
  # Filesystem = monta como sistema de arquivos (padrão)
  # Block = monta como dispositivo de bloco raw
  volumeMode: Filesystem

---

# ===========================================
# SERVICE - Expõe o PostgreSQL internamente
# ===========================================

apiVersion: v1
kind: Service
metadata:
  # Nome do Service (usado como hostname interno)
  name: postgres-service
  
  # Namespace onde será criado
  namespace: vehicle-sales
  
  # Labels para organização
  labels:
    app: postgres
    component: database
    tier: data
    service: vehicle-catalog
  
  # Annotations para configurações específicas
  annotations:
    description: "Service interno para PostgreSQL do Vehicle Catalog"

spec:
  # ===========================================
  # Tipo do Service
  # ===========================================
  # ClusterIP = acessível apenas dentro do cluster (padrão)
  # NodePort = acessível via porta do node
  # LoadBalancer = cria load balancer externo (cloud)
  # ExternalName = mapeia para DNS externo
  type: ClusterIP
  
  # ===========================================
  # Seletor de Pods
  # ===========================================
  # Define quais pods receberão tráfego deste service
  selector:
    app: postgres
    component: database
  
  # ===========================================
  # Portas
  # ===========================================
  ports:
    - name: postgres           # Nome da porta (referência)
      port: 5432              # Porta do Service
      targetPort: 5432        # Porta do Container
      protocol: TCP           # Protocolo (TCP/UDP/SCTP)
      
      # NodePort específico (apenas se type: NodePort)
      # nodePort: 30432
  
  # ===========================================
  # Session Affinity 
  # ===========================================
  # None = requisições distribuídas entre pods
  # ClientIP = requisições do mesmo IP vão pro mesmo pod
  sessionAffinity: None
  
  # Timeout da sessão (se usar ClientIP)
  # sessionAffinityConfig:
  #   clientIP:
  #     timeoutSeconds: 10800  # 3 horas